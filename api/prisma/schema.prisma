generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int                        @id @default(autoincrement())
  name                     String
  email                    String                     @unique
  password                 String
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @default(now()) @updatedAt
  refreshToken             String?
  profilePictureUrl        String?
  resetPasswordCode        String?
  resetPasswordExpires     DateTime?
  emailVerificationCode    String?
  emailVerificationExpires DateTime?
  emailVerified            Boolean                    @default(false)
  level                    Int                        @default(1)
  xp                       Int                        @default(0)
  lastXpGainDate           DateTime?
  tokenVersion             Int                        @default(0)
  conversationParticipants ConversationParticipant[]
  exercicesCreated         Exercice[]                 @relation("ExerciceCreatedBy")
  fitnessProfiles          FitnessProfile?
  friendsOf                Friend[]                   @relation("UserFriendsReverse")
  friends                  Friend[]                   @relation("UserFriends")
  adminOfGroups            FriendGroup[]              @relation("GroupAdmin")
  receivedGroupRequests    FriendGroupRequest[]       @relation("ReceivedGroupRequests")
  sentGroupRequests        FriendGroupRequest[]       @relation("SentGroupRequests")
  receivedRequests         FriendRequest[]            @relation("ReceivedRequests")
  sentRequests             FriendRequest[]            @relation("SentRequests")
  messages                 Message[]
  messageReactions         MessageReaction[]
  sessionPhotos            SessionPhoto[]
  organizedSessions        SharedSession[]            @relation("OrganizedSessions")
  SharedSession            SharedSession[]
  participatingSessions    SharedSessionParticipant[]
  subscription             Subscription?

  groups            FriendGroup[]      @relation("GroupMembers")
  shareActivities   Boolean            @default(false)
  activities        Activity[]
  activityReactions ActivityReaction[]
  userBadges        UserBadge[]
  badgeProgress     BadgeProgress[]
  pinnedBadges      Int[]              @default([])
  friendCode        String?            @unique

  // üéØ BODY ATLAS Relations
  muscleStats      UserMuscleStats[]
  mirrorMatchesAs1 MirrorMatch[]     @relation("MirrorMatchUser1")
  mirrorMatchesAs2 MirrorMatch[]     @relation("MirrorMatchUser2")
  LeaderboardStats LeaderboardStats?
}

model Activity {
  id        Int                @id @default(autoincrement())
  type      ActivityType
  userId    Int
  data      Json
  createdAt DateTime           @default(now())
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  reactions ActivityReaction[]

  @@index([userId])
  @@index([createdAt])
}

model ActivityReaction {
  id         Int      @id @default(autoincrement())
  activityId Int
  userId     Int
  emoji      String
  createdAt  DateTime @default(now())
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([activityId, userId])
}

model Badge {
  id          Int           @id @default(autoincrement())
  code        String        @unique
  name        String
  description String
  category    BadgeCategory
  tier        BadgeTier
  iconUrl     String?
  xpReward    Int           @default(0)
  requirement Json
  isSecret    Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  userBadges  UserBadge[]

  @@index([category])
  @@index([tier])
}

model UserBadge {
  id          Int      @id @default(autoincrement())
  userId      Int
  badgeId     Int
  unlockedAt  DateTime @default(now())
  progress    Int      @default(0)
  isDisplayed Boolean  @default(true)

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge Badge @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
}

model BadgeProgress {
  id           Int      @id @default(autoincrement())
  userId       Int
  badgeCode    String
  currentValue Int      @default(0)
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeCode])
  @@index([userId])
}

enum ActivityType {
  SESSION_COMPLETED
  PERSONAL_RECORD
  PROGRAM_COMPLETED
  STREAK_REACHED
  SESSION_SHARED
  BADGE_UNLOCKED
}

model FitnessProfile {
  id                Int             @id @default(autoincrement())
  userId            Int             @unique
  age               Int
  height            Float
  weight            Float
  trainingFrequency Int
  experienceLevel   ExperienceLevel
  goals             Goal[]
  gender            Gender
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @default(now()) @updatedAt
  bodyWeight        Boolean         @default(true)
  trainingDays      WeekDay[]
  city              String?

  // üÜï Nouveaux champs pour personnalisation avanc√©e
  targetWeight        Float?
  musclePriorities    Int[]               @default([]) // IDs des MuscleGroup prioritaires
  trainingEnvironment TrainingEnvironment @default(GYM)

  user             User              @relation(fields: [userId], references: [id])
  trainingPrograms TrainingProgram[]
  weightHistory    WeightHistory[]
}

model WeightHistory {
  id               Int            @id @default(autoincrement())
  fitnessProfileId Int
  weight           Float
  date             DateTime       @default(now())
  fitnessProfile   FitnessProfile @relation(fields: [fitnessProfileId], references: [id], onDelete: Cascade)
}

model TrainingProgram {
  id               Int              @id @default(autoincrement())
  fitnessProfileId Int
  name             String
  status           ProgramStatus    @default(DRAFT)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @default(now()) @updatedAt
  template         ProgramTemplate?
  startDate        DateTime         @default(now())
  fitnessProfile   FitnessProfile   @relation(fields: [fitnessProfileId], references: [id], onDelete: Cascade)

  // üÜï Templates de s√©ances (mod√®les r√©utilisables)
  sessionTemplates SessionTemplate[]

  // Sessions r√©elles (instances)
  sessions TrainingSession[]
}

// üÜï Template de session (le mod√®le r√©utilisable)
model SessionTemplate {
  id             Int      @id @default(autoincrement())
  programId      Int
  name           String
  description    String?
  orderInProgram Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  trainingProgram TrainingProgram    @relation(fields: [programId], references: [id], onDelete: Cascade)
  exercises       ExerciseTemplate[] // Exercices du template
  instances       TrainingSession[] // Instances cr√©√©es depuis ce template

  @@index([programId])
  @@index([programId, orderInProgram])
}

// üÜï Exercice dans un template
model ExerciseTemplate {
  id                Int      @id @default(autoincrement())
  sessionTemplateId Int
  exerciseId        Int
  orderInSession    Int      @default(0)
  sets              Int      @default(3)
  reps              Int      @default(8)
  weight            Float?
  duration          Int? // üÜï Dur√©e en minutes (pour exercices cardio)
  notes             String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  sessionTemplate SessionTemplate @relation(fields: [sessionTemplateId], references: [id], onDelete: Cascade)
  exercise        Exercice        @relation(fields: [exerciseId], references: [id], onDelete: Restrict)

  @@index([sessionTemplateId])
  @@index([sessionTemplateId, orderInSession])
}

model TrainingSession {
  id        Int @id @default(autoincrement())
  programId Int

  // üÜï Lien vers le template source (null si session manuelle)
  sessionTemplateId Int?

  // üÜï Statut du cycle de vie de la session
  status SessionStatus @default(SCHEDULED)

  date        DateTime?
  duration    Int?
  sessionName String?
  createdAt   DateTime  @default(now())

  // ‚ö†Ô∏è DEPRECATED - Remplac√© par sessionTemplateId (garde pour migration)
  originalSessionId Int?

  updatedAt                DateTime                   @default(now()) @updatedAt
  completed                Boolean                    @default(false)
  performedAt              DateTime?
  exercices                ExerciceSession[]
  sessionPhotos            SessionPhoto[]
  SharedSession            SharedSession[]
  SharedSessionParticipant SharedSessionParticipant[]
  trainingProgram          TrainingProgram            @relation(fields: [programId], references: [id], onDelete: Cascade)

  // üÜï Relation vers le template source
  sessionTemplate SessionTemplate? @relation(fields: [sessionTemplateId], references: [id], onDelete: SetNull)

  summary SessionSummary?

  @@index([programId, completed])
  @@index([programId, status])
  @@index([performedAt])
  @@index([sessionTemplateId])
}

model SessionSummary {
  id             Int             @id @default(autoincrement())
  sessionId      Int             @unique
  totalSets      Int
  totalReps      Int
  totalVolume    Float
  avgRPE         Float?
  caloriesBurned Float?
  duration       Int?
  muscleGroups   String[]
  createdAt      DateTime        @default(now())
  session        TrainingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}

model SessionPhoto {
  id          Int             @id @default(autoincrement())
  sessionId   Int
  userId      Int
  photoUrl    String
  createdAt   DateTime        @default(now())
  description String?
  session     TrainingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Exercice {
  name            String
  description     String?
  createdAt       DateTime              @default(now())
  id              Int                   @id @default(autoincrement())
  updatedAt       DateTime              @default(now()) @updatedAt
  difficulty      Int
  popularity      Int                   @default(0)
  effectiveness   Int?
  fatigueLevel    Int?
  tier            ExerciseTier          @default(STANDARD)
  createdByUserId Int?
  isDefault       Boolean               @default(false)
  type            ExerciceType?
  Materials       Boolean               @default(false)
  bodyWeight      Boolean               @default(false)
  imageUrl        String?
  createdBy       User?                 @relation("ExerciceCreatedBy", fields: [createdByUserId], references: [id], onDelete: Cascade)
  equipments      ExerciceEquipment[]
  groupes         ExerciceMuscleGroup[]
  trainingSession ExerciceSession[]

  // üÜï Relation vers les templates
  exerciseTemplates ExerciseTemplate[]
}

enum ExerciseTier {
  STAPLE
  STANDARD
  NICHE
}

model ExerciceSession {
  id              Int              @id @default(autoincrement())
  sessionId       Int
  exerciceId      Int
  sets            Int
  reps            Int
  weight          Float?
  exercice        Exercice         @relation(fields: [exerciceId], references: [id], onDelete: Cascade)
  trainingSession TrainingSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  performances    SetPerformance[]

  @@unique([sessionId, exerciceId])
}

model SetPerformance {
  id_set              Int             @id @default(autoincrement())
  id_exercice_session Int
  set_index           Int
  reps_effectuees     Int?
  reps_prevues        Int?
  weight              Float?
  rpe                 Int?
  success             Boolean?        @default(true)
  exerciceSession     ExerciceSession @relation(fields: [id_exercice_session], references: [id], onDelete: Cascade)
}

model ExerciceMuscleGroup {
  exerciceId Int
  groupeId   Int
  isPrimary  Boolean     @default(false) // üÜï Identifie le muscle principal cibl√© par l'exercice
  exercice   Exercice    @relation(fields: [exerciceId], references: [id], onDelete: Cascade)
  groupe     MuscleGroup @relation(fields: [groupeId], references: [id], onDelete: Cascade)

  @@id([exerciceId, groupeId])
}

model MuscleGroup {
  id        Int                   @id @default(autoincrement())
  name      String                @unique
  category  MuscleCategory        @default(OTHER)
  exercices ExerciceMuscleGroup[]
  userStats UserMuscleStats[]
}

// üéØ BODY ATLAS: Statistiques musculaires par utilisateur
model UserMuscleStats {
  id            Int       @id @default(autoincrement())
  userId        Int
  muscleGroupId Int
  totalVolume   Float     @default(0) // Volume cumul√© (kg √ó reps)
  level         Int       @default(0) // 0-5 (Novice √† Legend)
  lastTrainedAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  muscleGroup MuscleGroup @relation(fields: [muscleGroupId], references: [id], onDelete: Cascade)

  @@unique([userId, muscleGroupId])
  @@index([userId])
  @@index([lastTrainedAt])
}

// üéØ BODY ATLAS: Mirror Match (duels en temps r√©el)
model MirrorMatch {
  id            String      @id @default(uuid())
  user1Id       Int
  user2Id       Int
  muscleGroupId Int
  user1Volume   Float       @default(0)
  user2Volume   Float       @default(0)
  status        MatchStatus @default(ACTIVE)
  startedAt     DateTime    @default(now())
  endedAt       DateTime?
  winnerId      Int?

  user1 User @relation("MirrorMatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("MirrorMatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@index([user1Id])
  @@index([user2Id])
  @@index([status])
}

model Equipment {
  id          Int                 @id @default(autoincrement())
  name        String              @unique
  description String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @default(now()) @updatedAt
  exercices   ExerciceEquipment[]
}

model ExerciceEquipment {
  exerciceId  Int
  equipmentId Int
  equipment   Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  exercice    Exercice  @relation(fields: [exerciceId], references: [id], onDelete: Cascade)

  @@id([exerciceId, equipmentId])
}

model Friend {
  id       Int          @id @default(autoincrement())
  userId   Int
  friendId Int
  status   FriendStatus @default(ACCEPTED)
  friend   User         @relation("UserFriendsReverse", fields: [friendId], references: [id])
  user     User         @relation("UserFriends", fields: [userId], references: [id])

  @@unique([userId, friendId])
}

model FriendRequest {
  id         String        @id @default(uuid())
  senderId   Int
  receiverId Int
  status     RequestStatus @default(PENDING)
  createdAt  DateTime      @default(now())
  receiver   User          @relation("ReceivedRequests", fields: [receiverId], references: [id])
  sender     User          @relation("SentRequests", fields: [senderId], references: [id])

  @@unique([senderId, receiverId])
}

model FriendGroup {
  id             Int                  @id @default(autoincrement())
  name           String
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  adminId        Int?
  conversations  Conversation[]
  admin          User?                @relation("GroupAdmin", fields: [adminId], references: [id])
  joinRequests   FriendGroupRequest[] @relation("GroupJoinRequests")
  sharedSessions SharedSession[]
  members        User[]               @relation("GroupMembers")
}

model FriendGroupRequest {
  id         String      @id @default(uuid())
  senderId   Int
  groupId    Int
  status     GroupStatus @default(PENDING)
  createdAt  DateTime    @default(now())
  receiverId Int
  group      FriendGroup @relation("GroupJoinRequests", fields: [groupId], references: [id])
  receiver   User        @relation("ReceivedGroupRequests", fields: [receiverId], references: [id])
  sender     User        @relation("SentGroupRequests", fields: [senderId], references: [id])

  @@unique([senderId, groupId])
}

model Conversation {
  id           String                    @id @default(uuid())
  type         ConversationType
  groupId      Int?
  name         String?
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  group        FriendGroup?              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages     Message[]

  @@index([type])
  @@index([groupId])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         Int
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String            @id @default(uuid())
  conversationId String
  senderId       Int
  content        String
  type           MessageType       @default(TEXT)
  mediaUrl       String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  isEdited       Boolean           @default(false)
  isDeleted      Boolean           @default(false)
  conversation   Conversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User              @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reactions      MessageReaction[]

  @@index([conversationId, createdAt])
  @@index([senderId])
}

model MessageReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    Int
  emoji     String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
}

model SharedSession {
  id                String                     @id @default(uuid())
  title             String
  description       String?
  startTime         DateTime
  location          String?                    @default("Gym")
  maxParticipants   Int?
  organizerId       Int
  groupId           Int?
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  userId            Int?
  trainingSessionId Int?
  group             FriendGroup?               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  organizer         User                       @relation("OrganizedSessions", fields: [organizerId], references: [id], onDelete: Cascade)
  TrainingSession   TrainingSession?           @relation(fields: [trainingSessionId], references: [id])
  User              User?                      @relation(fields: [userId], references: [id])
  participants      SharedSessionParticipant[]

  @@index([organizerId])
  @@index([groupId])
  @@index([startTime])
}

model SharedSessionParticipant {
  id                String           @id @default(uuid())
  sharedSessionId   String
  userId            Int
  joinedAt          DateTime         @default(now())
  trainingSessionId Int?
  sharedSession     SharedSession    @relation(fields: [sharedSessionId], references: [id], onDelete: Cascade)
  TrainingSession   TrainingSession? @relation(fields: [trainingSessionId], references: [id])
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sharedSessionId, userId])
  @@index([userId])
}

model Subscription {
  id                Int              @id @default(autoincrement())
  userId            Int              @unique
  plan              SubscriptionPlan @default(FREE)
  status            PremiumStatus    @default(EXPIRED)
  startDate         DateTime?
  endDate           DateTime?
  trialStartDate    DateTime?
  trialEndDate      DateTime?
  cancelledAt       DateTime?
  lastPaymentDate   DateTime?
  nextBillingDate   DateTime?
  paymentProvider   String?
  externalPaymentId String?
  autoRenew         Boolean          @default(false)
  cancelledBy       String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([endDate])
}

// üèÜ LEADERBOARD: Statistiques pr√©calcul√©es pour performance optimale
model LeaderboardStats {
  id                     Int       @id @default(autoincrement())
  userId                 Int       @unique
  totalSessionsCompleted Int       @default(0)
  currentStreak          Int       @default(0)
  longestStreak          Int       @default(0)
  totalVolume            Float     @default(0) // Volume total lev√© (kg)
  totalWorkouts          Int       @default(0) // Alias de totalSessionsCompleted
  averageSessionDuration Float? // Dur√©e moyenne des sessions (minutes)
  personalRecordsCount   Int       @default(0) // Nombre de PRs
  lastWorkoutDate        DateTime?
  updatedAt              DateTime  @updatedAt
  createdAt              DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([totalSessionsCompleted])
  @@index([currentStreak])
  @@index([totalVolume])
}

enum ExperienceLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum Goal {
  WEIGHT_LOSS
  MUSCLE_GAIN
  ENDURANCE
  MAINTENANCE
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum ProgramStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
  DRAFT
}

enum FriendStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum GroupStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum ExerciceType {
  COMPOUND
  ISOLATION
  CARDIO
  MOBILITY
  STRETCH
}

enum ProgramTemplate {
  FULL_BODY // 1-2j : Tout le corps (flexible, tous niveaux)
  UPPER_LOWER // 4j : Haut/Bas altern√© (interm√©diaires)
  PUSH_PULL_LEGS // 3j : Push/Pull/Jambes classique
  PPL_UPPER_LOWER // 5j : PPL + Upper/Lower (volume optimal)
  PPL_X2 // 6j : PPL x2 (chaque muscle 2x/semaine)
  PPL_X2_FULL_BODY // 7j : PPL x2 + Full Body (volume maximal)
  CUSTOM // Variable : Personnalis√©
}

enum ConversationType {
  PRIVATE
  GROUP
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  SYSTEM
  INVITATION
}

enum PremiumStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  TRIAL
}

enum SubscriptionPlan {
  FREE
  MONTHLY
  YEARLY
  LIFETIME
}

enum WeekDay {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
  CUSTOM
}

enum TrainingEnvironment {
  HOME
  GYM
}

enum BadgeCategory {
  TRAINING
  SOCIAL
  PROGRESSION
  SPECIAL
}

enum BadgeTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  LEGENDARY
}

// üéØ BODY ATLAS Enums
enum MuscleCategory {
  CHEST
  BACK
  SHOULDERS
  ARMS
  LEGS
  CORE
  OTHER
}

// üÜï TRAINING SESSION Status
enum SessionStatus {
  SCHEDULED // Planifi√©e, pas encore d√©marr√©e
  IN_PROGRESS // En cours d'ex√©cution
  COMPLETED // Termin√©e avec succ√®s
  CANCELLED // Annul√©e par l'utilisateur
}

enum MuscleHeat {
  HOT // 0-72h (r√©cemment travaill√©)
  WARM // 72h-120h (pr√™t √† retravailler)
  COLD // 120h+ (n√©glig√©)
  FROZEN // 7j+ (perd du niveau)
}

enum MatchStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}
