generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int                        @id @default(autoincrement())
  name                     String
  email                    String                     @unique
  password                 String
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @default(now()) @updatedAt
  refreshToken             String?
  profilePictureUrl        String?
  resetPasswordCode        String?
  resetPasswordExpires     DateTime?
  emailVerificationCode    String?
  emailVerificationExpires DateTime?
  emailVerified            Boolean                    @default(false)
  level                    Int                        @default(1)
  xp                       Int                        @default(0)
  lastXpGainDate           DateTime?
  tokenVersion             Int                        @default(0)
  conversationParticipants ConversationParticipant[]
  exercicesCreated         Exercice[]                 @relation("ExerciceCreatedBy")
  fitnessProfiles          FitnessProfile?
  friendsOf                Friend[]                   @relation("UserFriendsReverse")
  friends                  Friend[]                   @relation("UserFriends")
  adminOfGroups            FriendGroup[]              @relation("GroupAdmin")
  receivedGroupRequests    FriendGroupRequest[]       @relation("ReceivedGroupRequests")
  sentGroupRequests        FriendGroupRequest[]       @relation("SentGroupRequests")
  receivedRequests         FriendRequest[]            @relation("ReceivedRequests")
  sentRequests             FriendRequest[]            @relation("SentRequests")
  messages                 Message[]
  messageReactions         MessageReaction[]
  sessionPhotos            SessionPhoto[]
  organizedSessions        SharedSession[]            @relation("OrganizedSessions")
  SharedSession            SharedSession[]
  participatingSessions    SharedSessionParticipant[]
  subscription             Subscription?

  groups            FriendGroup[]      @relation("GroupMembers")
  shareActivities   Boolean            @default(false)
  activities        Activity[]
  activityReactions ActivityReaction[]
  userBadges        UserBadge[]
  badgeProgress     BadgeProgress[]
  pinnedBadges      Int[]              @default([])
  friendCode        String?            @unique

  // ðŸŽ¯ BODY ATLAS Relations
  muscleStats      UserMuscleStats[]
  mirrorMatchesAs1 MirrorMatch[]     @relation("MirrorMatchUser1")
  mirrorMatchesAs2 MirrorMatch[]     @relation("MirrorMatchUser2")
}

model Activity {
  id        Int                @id @default(autoincrement())
  type      ActivityType
  userId    Int
  data      Json
  createdAt DateTime           @default(now())
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  reactions ActivityReaction[]

  @@index([userId])
  @@index([createdAt])
}

model ActivityReaction {
  id         Int      @id @default(autoincrement())
  activityId Int
  userId     Int
  emoji      String
  createdAt  DateTime @default(now())
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([activityId, userId])
}

model Badge {
  id          Int           @id @default(autoincrement())
  code        String        @unique
  name        String
  description String
  category    BadgeCategory
  tier        BadgeTier
  iconUrl     String?
  xpReward    Int           @default(0)
  requirement Json
  isSecret    Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  userBadges  UserBadge[]

  @@index([category])
  @@index([tier])
}

model UserBadge {
  id          Int      @id @default(autoincrement())
  userId      Int
  badgeId     Int
  unlockedAt  DateTime @default(now())
  progress    Int      @default(0)
  isDisplayed Boolean  @default(true)

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge Badge @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
}

model BadgeProgress {
  id           Int      @id @default(autoincrement())
  userId       Int
  badgeCode    String
  currentValue Int      @default(0)
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeCode])
  @@index([userId])
}

enum ActivityType {
  SESSION_COMPLETED
  PERSONAL_RECORD
  PROGRAM_COMPLETED
  STREAK_REACHED
  SESSION_SHARED
}

model FitnessProfile {
  id                Int             @id @default(autoincrement())
  userId            Int             @unique
  age               Int
  height            Float
  weight            Float
  trainingFrequency Int
  experienceLevel   ExperienceLevel
  goals             Goal[]
  gender            Gender
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @default(now()) @updatedAt
  bodyWeight        Boolean         @default(true)
  trainingDays      WeekDay[]
  city              String?

  // ðŸ†• Nouveaux champs pour personnalisation avancÃ©e
  targetWeight        Float?
  musclePriorities    Int[]               @default([]) // IDs des MuscleGroup prioritaires
  trainingEnvironment TrainingEnvironment @default(GYM)

  user             User              @relation(fields: [userId], references: [id])
  trainingPrograms TrainingProgram[]
  weightHistory    WeightHistory[]
}

model WeightHistory {
  id               Int            @id @default(autoincrement())
  fitnessProfileId Int
  weight           Float
  date             DateTime       @default(now())
  fitnessProfile   FitnessProfile @relation(fields: [fitnessProfileId], references: [id], onDelete: Cascade)
}

model TrainingProgram {
  id               Int               @id @default(autoincrement())
  fitnessProfileId Int
  name             String
  description      String?
  status           ProgramStatus     @default(DRAFT)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @default(now()) @updatedAt
  template         ProgramTemplate?
  startDate        DateTime          @default(now())
  fitnessProfile   FitnessProfile    @relation(fields: [fitnessProfileId], references: [id], onDelete: Cascade)
  sessions         TrainingSession[]
}

model TrainingSession {
  id                       Int                        @id @default(autoincrement())
  programId                Int
  date                     DateTime?
  duration                 Int?
  sessionName              String?
  createdAt                DateTime                   @default(now())
  originalSessionId        Int?
  updatedAt                DateTime                   @default(now()) @updatedAt
  completed                Boolean                    @default(false)
  performedAt              DateTime?
  exercices                ExerciceSession[]
  sessionPhotos            SessionPhoto[]
  SharedSession            SharedSession[]
  SharedSessionParticipant SharedSessionParticipant[]
  trainingProgram          TrainingProgram            @relation(fields: [programId], references: [id], onDelete: Cascade)
  summary                  SessionSummary?
}

model SessionSummary {
  id           Int             @id @default(autoincrement())
  sessionId    Int             @unique
  totalSets    Int
  totalReps    Int
  totalVolume  Float
  avgRPE       Float?
  duration     Int?
  muscleGroups String[]
  createdAt    DateTime        @default(now())
  session      TrainingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}

model SessionPhoto {
  id          Int             @id @default(autoincrement())
  sessionId   Int
  userId      Int
  photoUrl    String
  createdAt   DateTime        @default(now())
  description String?
  session     TrainingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Exercice {
  name            String
  description     String?
  createdAt       DateTime              @default(now())
  id              Int                   @id @default(autoincrement())
  updatedAt       DateTime              @default(now()) @updatedAt
  difficulty      Int
  createdByUserId Int?
  isDefault       Boolean               @default(false)
  type            ExerciceType?
  Materials       Boolean               @default(false)
  bodyWeight      Boolean               @default(false)
  imageUrl        String?
  createdBy       User?                 @relation("ExerciceCreatedBy", fields: [createdByUserId], references: [id], onDelete: Cascade)
  equipments      ExerciceEquipment[]
  groupes         ExerciceMuscleGroup[]
  trainingSession ExerciceSession[]
}

model ExerciceSession {
  id              Int              @id @default(autoincrement())
  sessionId       Int
  exerciceId      Int
  sets            Int
  reps            Int
  weight          Float?
  exercice        Exercice         @relation(fields: [exerciceId], references: [id], onDelete: Cascade)
  trainingSession TrainingSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  performances    SetPerformance[]

  @@unique([sessionId, exerciceId])
}

model SetPerformance {
  id_set              Int             @id @default(autoincrement())
  id_exercice_session Int
  set_index           Int
  reps_effectuees     Int?
  reps_prevues        Int?
  weight              Float?
  rpe                 Int?
  success             Boolean?        @default(true)
  exerciceSession     ExerciceSession @relation(fields: [id_exercice_session], references: [id], onDelete: Cascade)
}

model ExerciceMuscleGroup {
  exerciceId Int
  groupeId   Int
  exercice   Exercice    @relation(fields: [exerciceId], references: [id], onDelete: Cascade)
  groupe     MuscleGroup @relation(fields: [groupeId], references: [id], onDelete: Cascade)

  @@id([exerciceId, groupeId])
}

model MuscleGroup {
  id        Int                   @id @default(autoincrement())
  name      String                @unique
  category  MuscleCategory        @default(OTHER)
  exercices ExerciceMuscleGroup[]
  userStats UserMuscleStats[]
}

// ðŸŽ¯ BODY ATLAS: Statistiques musculaires par utilisateur
model UserMuscleStats {
  id            Int       @id @default(autoincrement())
  userId        Int
  muscleGroupId Int
  totalVolume   Float     @default(0) // Volume cumulÃ© (kg Ã— reps)
  level         Int       @default(0) // 0-5 (Novice Ã  Legend)
  lastTrainedAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  muscleGroup MuscleGroup @relation(fields: [muscleGroupId], references: [id], onDelete: Cascade)

  @@unique([userId, muscleGroupId])
  @@index([userId])
  @@index([lastTrainedAt])
}

// ðŸŽ¯ BODY ATLAS: Mirror Match (duels en temps rÃ©el)
model MirrorMatch {
  id            String      @id @default(uuid())
  user1Id       Int
  user2Id       Int
  muscleGroupId Int
  user1Volume   Float       @default(0)
  user2Volume   Float       @default(0)
  status        MatchStatus @default(ACTIVE)
  startedAt     DateTime    @default(now())
  endedAt       DateTime?
  winnerId      Int?

  user1 User @relation("MirrorMatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("MirrorMatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@index([user1Id])
  @@index([user2Id])
  @@index([status])
}

model Equipment {
  id          Int                 @id @default(autoincrement())
  name        String              @unique
  description String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @default(now()) @updatedAt
  exercices   ExerciceEquipment[]
}

model ExerciceEquipment {
  exerciceId  Int
  equipmentId Int
  equipment   Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  exercice    Exercice  @relation(fields: [exerciceId], references: [id], onDelete: Cascade)

  @@id([exerciceId, equipmentId])
}

model Friend {
  id       Int          @id @default(autoincrement())
  userId   Int
  friendId Int
  status   FriendStatus @default(ACCEPTED)
  friend   User         @relation("UserFriendsReverse", fields: [friendId], references: [id])
  user     User         @relation("UserFriends", fields: [userId], references: [id])

  @@unique([userId, friendId])
}

model FriendRequest {
  id         String        @id @default(uuid())
  senderId   Int
  receiverId Int
  status     RequestStatus @default(PENDING)
  createdAt  DateTime      @default(now())
  receiver   User          @relation("ReceivedRequests", fields: [receiverId], references: [id])
  sender     User          @relation("SentRequests", fields: [senderId], references: [id])

  @@unique([senderId, receiverId])
}

model FriendGroup {
  id             Int                  @id @default(autoincrement())
  name           String
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  adminId        Int?
  conversations  Conversation[]
  admin          User?                @relation("GroupAdmin", fields: [adminId], references: [id])
  joinRequests   FriendGroupRequest[] @relation("GroupJoinRequests")
  sharedSessions SharedSession[]
  members        User[]               @relation("GroupMembers")
}

model FriendGroupRequest {
  id         String      @id @default(uuid())
  senderId   Int
  groupId    Int
  status     GroupStatus @default(PENDING)
  createdAt  DateTime    @default(now())
  receiverId Int
  group      FriendGroup @relation("GroupJoinRequests", fields: [groupId], references: [id])
  receiver   User        @relation("ReceivedGroupRequests", fields: [receiverId], references: [id])
  sender     User        @relation("SentGroupRequests", fields: [senderId], references: [id])

  @@unique([senderId, groupId])
}

model Conversation {
  id           String                    @id @default(uuid())
  type         ConversationType
  groupId      Int?
  name         String?
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  group        FriendGroup?              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages     Message[]

  @@index([type])
  @@index([groupId])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         Int
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String            @id @default(uuid())
  conversationId String
  senderId       Int
  content        String
  type           MessageType       @default(TEXT)
  mediaUrl       String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  isEdited       Boolean           @default(false)
  isDeleted      Boolean           @default(false)
  conversation   Conversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User              @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reactions      MessageReaction[]

  @@index([conversationId, createdAt])
  @@index([senderId])
}

model MessageReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    Int
  emoji     String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
}

model SharedSession {
  id                String                     @id @default(uuid())
  title             String
  description       String?
  startTime         DateTime
  location          String?                    @default("Gym")
  maxParticipants   Int?
  organizerId       Int
  groupId           Int?
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  userId            Int?
  trainingSessionId Int?
  group             FriendGroup?               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  organizer         User                       @relation("OrganizedSessions", fields: [organizerId], references: [id], onDelete: Cascade)
  TrainingSession   TrainingSession?           @relation(fields: [trainingSessionId], references: [id])
  User              User?                      @relation(fields: [userId], references: [id])
  participants      SharedSessionParticipant[]

  @@index([organizerId])
  @@index([groupId])
  @@index([startTime])
}

model SharedSessionParticipant {
  id                String           @id @default(uuid())
  sharedSessionId   String
  userId            Int
  joinedAt          DateTime         @default(now())
  trainingSessionId Int?
  sharedSession     SharedSession    @relation(fields: [sharedSessionId], references: [id], onDelete: Cascade)
  TrainingSession   TrainingSession? @relation(fields: [trainingSessionId], references: [id])
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sharedSessionId, userId])
  @@index([userId])
}

model Subscription {
  id                Int              @id @default(autoincrement())
  userId            Int              @unique
  plan              SubscriptionPlan @default(FREE)
  status            PremiumStatus    @default(EXPIRED)
  startDate         DateTime?
  endDate           DateTime?
  trialStartDate    DateTime?
  trialEndDate      DateTime?
  cancelledAt       DateTime?
  lastPaymentDate   DateTime?
  nextBillingDate   DateTime?
  paymentProvider   String?
  externalPaymentId String?
  autoRenew         Boolean          @default(false)
  cancelledBy       String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([endDate])
}

enum ExperienceLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum Goal {
  WEIGHT_LOSS
  MUSCLE_GAIN
  ENDURANCE
  MAINTENANCE
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum ProgramStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
  DRAFT
}

enum FriendStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum GroupStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum ExerciceType {
  COMPOUND
  ISOLATION
  CARDIO
  MOBILITY
  STRETCH
}

enum ProgramTemplate {
  FULL_BODY // 1-6j : Tout le corps (flexible, tous niveaux)
  UPPER_LOWER // 4j : Haut/Bas alternÃ© (intermÃ©diaires)
  PUSH_PULL_LEGS // 3j ou 6j : Push/Pull/Jambes (inter/avancÃ©s)
  BRO_SPLIT // 5-6j : 1 muscle/jour (avancÃ©s bodybuilding)
  ARNOLD_SPLIT // 6j : Antagonistes 2x/semaine (avancÃ©s)
  CUSTOM // Variable : PersonnalisÃ©
}

enum ConversationType {
  PRIVATE
  GROUP
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  SYSTEM
  INVITATION
}

enum PremiumStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  TRIAL
}

enum SubscriptionPlan {
  FREE
  MONTHLY
  YEARLY
  LIFETIME
}

enum WeekDay {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
  CUSTOM
}

enum TrainingEnvironment {
  HOME
  GYM
}

enum BadgeCategory {
  TRAINING
  SOCIAL
  PROGRESSION
  SPECIAL
}

enum BadgeTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  LEGENDARY
}

// ðŸŽ¯ BODY ATLAS Enums
enum MuscleCategory {
  CHEST
  BACK
  SHOULDERS
  ARMS
  LEGS
  CORE
  OTHER
}

enum MuscleHeat {
  HOT // 0-72h (rÃ©cemment travaillÃ©)
  WARM // 72h-120h (prÃªt Ã  retravailler)
  COLD // 120h+ (nÃ©gligÃ©)
  FROZEN // 7j+ (perd du niveau)
}

enum MatchStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}
